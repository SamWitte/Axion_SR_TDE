using LinearAlgebra, DifferentialEquations

# -------------------------- Precision-generic types --------------------------
# HeunParams parameterized by floating type T
struct HeunParams{T<:AbstractFloat}
    α::Complex{T}
    q::Complex{T}
    γ::Complex{T}
    δ::Complex{T}
    ε::Complex{T}
end

# Helper to create Complex{T} literal like 1.0+0im for generic T
_complex_one(::Type{T}) where {T<:AbstractFloat} = Complex{T}(one(T), zero(T))
_complex_zero(::Type{T}) where {T<:AbstractFloat} = Complex{T}(zero(T), zero(T))

# small helper to compute cis(theta) for generic T (theta should be Real of same precision)
function _cis(theta::T) where {T<:AbstractFloat}
    # cis(x) = cos(x) + i*sin(x)
    return Complex{T}(cos(T(theta)), sin(T(theta)))
end

# -------------------------- ODE on real parameter tau -------------------------
# pwrap.params is HeunParams{T}, pwrap.z0 and pwrap.zt are Complex{T}
function heun_ode_path_generic!(du, u, pwrap, τ)
    # u and du will be Complex{T} vector
    y = u[1]
    yp = u[2]

    p = pwrap.params
    z0 = pwrap.z0
    zt = pwrap.zt

    # compute z(τ) = z0 + τ*(zt - z0)
    # τ is a Real (Float64) when solving in default; if using BigFloat solver τ may be BigFloat
    z = z0 + τ * (zt - z0)
    dz_dτ = (zt - z0)

    C1 = p.γ / z + p.δ / (z - one(real(z))) + p.ε
    C2 = (p.α * z - p.q) / (z * (z - one(real(z))))

    # derivatives wrt z
    dy_dz = yp
    dyp_dz = -C1 * yp - C2 * y

    # chain rule: d/dτ = dz/dτ * d/dz
    du[1] = dy_dz * dz_dτ
    du[2] = dyp_dz * dz_dτ
end

# wrapper that picks the right typed ODE function
heun_ode_path!(du, u, pwrap, τ) = heun_ode_path_generic!(du, u, pwrap, τ)

# -------------------------- Collocation-based series initializer ------------
"""
    heun_series_collocation(p::HeunParams{T}; N=30, z0=one(T)*1e-6, collocation_radius=one(T)*1e-3)

Build truncated series y(z)=sum_{k=0..N} a_k z^k with a0 = 1, by enforcing the confluent Heun ODE
at M = N collocation points near zero.

Returns `(a::Vector{Complex{T}}, y0::Complex{T}, yp0::Complex{T})`.
"""
function heun_series_collocation(p::HeunParams{T}; N::Int=30, z0::Complex{T}=Complex{T}(T(1e-6), zero(T)),
                                collocation_radius::T = T(1e-3)) where {T<:AbstractFloat}
    # Number of collocation equations
    M = N

    # Build collocation points inside radius; avoid exactly 0
    zs = Vector{Complex{T}}(undef, M)
    for j in 1:M
        r = collocation_radius * T(j) / T(M + 1)  # radial progression
        # create small angle in same precision
        theta = (2 * π) * (T(j-1) / T(M)) * T(0.37)
        # use generic cis
        zs[j] = r * _cis(theta)
    end

    # unknowns: a1..aN (a0 fixed to 1)
    A = zeros(Complex{T}, M, N)
    b = zeros(Complex{T}, M)

    one_ct = Complex{T}(one(T), zero(T))

    for (i, z) in enumerate(zs)
        C1 = p.γ / z + p.δ / (z - one_ct) + p.ε
        C2 = (p.α * z - p.q) / (z * (z - one_ct))

        # known contribution from a0=1 moved to RHS
        b[i] = -C2 * one_ct

        # fill row for a1..aN
        # note: j ranges 1..N corresponds to z^j terms
        for j in 1:N
            # y'': j*(j-1) * z^(j-2)
            term_ypp = Complex{T}(T(j * (j - 1)) , zero(T)) * z^(j - 2)
            # y': j * z^(j-1) * C1
            term_yp = Complex{T}(T(j), zero(T)) * z^(j - 1) * C1
            # y: z^j * C2
            term_y  = z^j * C2
            A[i, j] = term_ypp + term_yp + term_y
        end
    end

    # Solve for a1..aN (least-squares if M > N)
    a_rest = if M == N
        A \ b
    else
        qr(A) \ b
    end

    # build full coefficient vector a[1..N+1] with a0 = 1
    a = Vector{Complex{T}}(undef, N + 1)
    a[1] = one_ct
    for j in 1:N
        a[j+1] = a_rest[j]
    end

    # Evaluate series and derivative at z0
    y0 = zero(Complex{T})
    yp0 = zero(Complex{T})
    zpow = one_ct  # z0^0

    # careful: if z0 == 0, derivative uses only higher terms (we assume z0 small nonzero)
    for k in 0:N
        y0 += a[k+1] * zpow
        if k >= 1
            # z0^(k-1) = zpow / z0
            yp0 += Complex{T}(T(k), zero(T)) * a[k+1] * (zpow / z0)
        end
        zpow *= z0
    end

    return a, y0, yp0
end

# -------------------------- Wrapper that integrates -------------------------
"""
    heunC_numeric(p::HeunParams{T}, z_target{T}; N=30, z0, abstol, reltol)

Build collocation initializer at z0 and integrate along straight segment z0 -> z_target.
Returns `(a, y_target)` where `a` are series coefficients and `y_target` is y(z_target).
"""
function heunC_numeric(p::HeunParams{T}, z_target::Complex{T};
                       N::Int=30,
                       z0::Complex{T}=Complex{T}(T(1e-6), zero(T)),
                       abstol::T = T(1e-30),
                       reltol::T = T(1e-30)) where {T<:AbstractFloat}

    # produce series and initial conditions
    a, y0, yp0 = heun_series_collocation(p; N=N, z0=z0)

    # initial state vector (Complex{T})
    u0 = similar([y0, yp0])  # creates Vector{Complex{T}} and assigns types properly
    u0[1] = y0
    u0[2] = yp0

    # pack parameters into NamedTuple
    pwrap = (params = p, z0 = z0, zt = z_target)

    # define ODEProblem on τ ∈ [0,1]
    prob = ODEProblem(heun_ode_path!, u0, (zero(T), one(T)), pwrap)

    # solver tolerances: pick reasonable defaults for BigFloat; user can override
    sol = solve(prob, abstol = abstol, reltol = reltol)

    return a, sol(one(T))[1]
end

# -------------------------- Example usage -----------------------------------
# Float64 test





# --------------------------- Example usage -----------------------------------
# Choose some test parameters (complex) and evaluate:
a1 = 19.75084026151641617243411 + 0.49249468304607522880077923*im
a2 = -0.135872292082232464413753373192 + 461963321248978093101380210403*im
a3 = 1.00000000000000000000075 + 9.6368868327615906048507658649367412192079*im
a4 = 0.99999999999999999999960668567997582 + 10.84227164700903154*im
a5 = -0.0228699840498316764876 + 1.83529495082000813339362024e-21*im
z_target = BigFloat(-1.0) + BigFloat(0.0) * im

# BigFloat test (128 bits) — set precision first
setprecision(128) do
    T = BigFloat
    pbig = HeunParams{T}(a1, a2, a3, a4, a5)
    z_target_big = z_target
    abar, ybig = heunC_numeric(pbig, z_target_big; N=36,
                               abstol = T(1e-30), reltol = T(1e-30))
    println("BigFloat HeunC ≈ ", ybig)
end
